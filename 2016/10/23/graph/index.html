<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wadeee.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="从Floyd开始学图  关于图图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。 LeetCode真题990. Satisfiability of Equality Equations满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。查看原题 123456789Input:">
<meta property="og:type" content="article">
<meta property="og:title" content="Graph(图)">
<meta property="og:url" content="https://wadeee.github.io/2016/10/23/graph/index.html">
<meta property="og:site_name" content="Wade">
<meta property="og:description" content="从Floyd开始学图  关于图图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。 LeetCode真题990. Satisfiability of Equality Equations满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。查看原题 123456789Input:">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2016-10-22T16:00:00.000Z">
<meta property="article:modified_time" content="2020-07-31T02:14:45.438Z">
<meta property="article:author" content="Wade">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wadeee.github.io/2016/10/23/graph/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Graph(图) | Wade</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wade</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Know yourself.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://wadeee.github.io/2016/10/23/graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wade">
      <meta itemprop="description" content="用时间换空间，用空间换时间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wade">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Graph(图)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-23 00:00:00" itemprop="dateCreated datePublished" datetime="2016-10-23T00:00:00+08:00">2016-10-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>从Floyd开始学图</p>
</blockquote>
<h2 id="关于图"><a href="#关于图" class="headerlink" title="关于图"></a>关于图</h2><p>图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。</p>
<h2 id="LeetCode真题"><a href="#LeetCode真题" class="headerlink" title="LeetCode真题"></a>LeetCode真题</h2><h3 id="990-Satisfiability-of-Equality-Equations"><a href="#990-Satisfiability-of-Equality-Equations" class="headerlink" title="990. Satisfiability of Equality Equations"></a>990. Satisfiability of Equality Equations</h3><p>满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。<br><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: If we assign say, a &#x3D; 1 and b &#x3D; 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</span><br><span class="line"></span><br><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: [&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<ul>
<li><p>union find. 并查集。find方法可以想象成一个链表，返回的是链表末尾key,val相等的元素。同时建立连接关系。如a==b, b==c时fc={‘a’: ‘b’, ‘b’: ‘c’, ‘c’: ‘c’}比较a!=c时就会最终找到fc[‘a’] == ‘c’；如a==b, c==a时，fc={‘a’: ‘b’, ‘b’: ‘b’, ‘c’: ‘b’}。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: <span class="string">'List[str]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">    equations.sort(key=<span class="keyword">lambda</span> e: e[<span class="number">1</span>] == <span class="string">'!'</span>)</span><br><span class="line">    uf = &#123;a: a <span class="keyword">for</span> a <span class="keyword">in</span> string.ascii_lowercase&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]: </span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a, e, _, b <span class="keyword">in</span> equations:</span><br><span class="line">        <span class="keyword">if</span> e == <span class="string">"="</span>:</span><br><span class="line">            uf[find(a)] = find(b)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> find(a) == find(b):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="997-Find-the-Town-Judge"><a href="#997-Find-the-Town-Judge" class="headerlink" title="997. Find the Town Judge"></a>997. Find the Town Judge</h3><p>找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。<br><a href="https://leetcode.com/problems/find-the-town-judge/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 4, trust &#x3D; [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br><span class="line">Input: N &#x3D; 3, trust &#x3D; [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：brute force.</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trust:</span><br><span class="line">        <span class="keyword">return</span> N</span><br><span class="line">    a, b = zip(*trust)           </span><br><span class="line">    candidates = collections.Counter(b)</span><br><span class="line">    villages = set(a)</span><br><span class="line">    <span class="keyword">for</span> c, votes <span class="keyword">in</span> candidates.most_common():</span><br><span class="line">        <span class="keyword">if</span> votes &lt; N - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> villages:</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：定向图。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N: int, trust: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    count = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> trust:</span><br><span class="line">        count[i] -= <span class="number">1</span></span><br><span class="line">        count[j] += <span class="number">1</span></span><br><span class="line">        print(count)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> count[i] == N - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="133-Clone-Graph"><a href="#133-Clone-Graph" class="headerlink" title="133. Clone Graph"></a>133. Clone Graph</h3><p>深拷贝一个简单环。<br><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">查看原题</a></p>
<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">    cp = collections.defaultdict(<span class="keyword">lambda</span>: Node(<span class="number">0</span>, []))</span><br><span class="line">    nodes = [node]</span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">while</span> nodes:</span><br><span class="line">        n = nodes.pop()</span><br><span class="line">        cp[n].val = n.val</span><br><span class="line">        cp[n].neighbors = [cp[x] <span class="keyword">for</span> x <span class="keyword">in</span> n.neighbors]</span><br><span class="line">        nodes.extend(x <span class="keyword">for</span> x <span class="keyword">in</span> n.neighbors <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> seen)</span><br><span class="line">        seen.add(n)</span><br><span class="line">    <span class="keyword">return</span> cp[node]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance"><a href="#1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance" class="headerlink" title="1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance"></a>1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</h3><p>找到距离范围内邻居最少的城市。<br><a href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4, edges &#x3D; [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold &#x3D; 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The figure above describes the graph. </span><br><span class="line">The neighboring cities at a distanceThreshold &#x3D; 4 for each city are:</span><br><span class="line">City 0 -&gt; [City 1, City 2] </span><br><span class="line">City 1 -&gt; [City 0, City 2, City 3] </span><br><span class="line">City 2 -&gt; [City 0, City 1, City 3] </span><br><span class="line">City 3 -&gt; [City 1, City 2] </span><br><span class="line">Cities 0 and 3 have 2 neighboring cities at a distanceThreshold &#x3D; 4, but we have to return city 3 since it has the greatest number.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：狄克斯特拉算法。这里没想到用一个堆来维持最小的距离。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], distanceThreshold: int)</span> -&gt; int:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">        g[v].append((u, w))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_neighbor</span><span class="params">(city)</span>:</span></span><br><span class="line">        heap = [(<span class="number">0</span>, city)]</span><br><span class="line">        dist = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            cur_w, u = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> u <span class="keyword">in</span> dist:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> u != city:</span><br><span class="line">                dist[u] = cur_w</span><br><span class="line">            <span class="keyword">for</span> v, w <span class="keyword">in</span> g[u]:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">in</span> dist:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> cur_w + w &lt;= distanceThreshold:</span><br><span class="line">                    heapq.heappush(heap, (cur_w+w, v))</span><br><span class="line">        <span class="keyword">return</span> len(dist)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min(range(n), key=<span class="keyword">lambda</span> x: (count_neighbor(x), -x))</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：弗洛伊德算法，这个时间复杂度为O(N^3)，space: O(N^2)但是代码简单。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], maxd: int)</span> -&gt; int:</span></span><br><span class="line">    dis = [[float(<span class="string">'inf'</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i, j, w <span class="keyword">in</span> edges:</span><br><span class="line">        dis[i][j] = dis[j][i] = w</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dis[i][i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j])</span><br><span class="line">    ans = &#123;sum(d&lt;=maxd <span class="keyword">for</span> d <span class="keyword">in</span> dis[i]): i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;  <span class="comment"># 这里id大的会将小的覆盖</span></span><br><span class="line">    <span class="keyword">return</span> ans[min(ans)]</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="1267-Count-Servers-that-Communicate"><a href="#1267-Count-Servers-that-Communicate" class="headerlink" title="1267. Count Servers that Communicate"></a>1267. Count Servers that Communicate</h3><p>找到2个以上的服务器连接个数，服务器可以在一行或是一列算是连接上。<br><a href="https://leetcode.com/problems/count-servers-that-communicate/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can&#39;t communicate with any other server.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>行列累计求和，但是只是用来判断而不是累加，然后遍历所有的元素。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countServers</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    X, Y = tuple(map(sum, g)), tuple(map(sum, zip(*g)))</span><br><span class="line">    <span class="keyword">return</span> sum(X[i]+Y[j]&gt;<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(g)) <span class="keyword">for</span> j <span class="keyword">in</span> range(len(g[<span class="number">0</span>])) <span class="keyword">if</span> g[i][j])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="886-Possible-Bipartition"><a href="#886-Possible-Bipartition" class="headerlink" title="886. Possible Bipartition"></a>886. Possible Bipartition</h3><p>将不喜欢的人放在两组中，根据关系是否能将其分为2组。<br><a href="https://leetcode.com/problems/possible-bipartition/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br><span class="line"></span><br><span class="line">Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：dfs。等同于在一个无向图中，寻找一个奇数边的环。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">possibleBipartition</span><span class="params">(self, N: int, dislikes: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> dislikes:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        g[b].append(a)</span><br><span class="line"></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, p, p_len)</span>:</span></span><br><span class="line">        seen.add(i)</span><br><span class="line">        p[i] = p_len</span><br><span class="line">        <span class="keyword">for</span> nxt <span class="keyword">in</span> g[i]:</span><br><span class="line">            <span class="keyword">if</span> nxt <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">if</span> dfs(nxt, p, p_len+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> nxt <span class="keyword">in</span> p <span class="keyword">and</span> (p_len-p[nxt])&amp;<span class="number">1</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        p.pop(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    p = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> dfs(i, p, <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="207-Course-Schedule"><a href="#207-Course-Schedule" class="headerlink" title="207. Course Schedule"></a>207. Course Schedule</h3><p>课程调度，课程有依赖关系，问是否能完成所有的课程。<br><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：dfs。注意这里状态要用3中，1表示遍历过，-1表示正在遍历，0表未遍历。这样可以避免重复的遍历。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, n: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">    g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[a].append(b)</span><br><span class="line">        </span><br><span class="line">    seen = [<span class="number">0</span>] * n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> seen[i] <span class="keyword">in</span> &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;: <span class="keyword">return</span> seen[i]==<span class="number">1</span></span><br><span class="line">        seen[i] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> any(<span class="keyword">not</span> dfs(j) <span class="keyword">for</span> j <span class="keyword">in</span> g[i]): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        seen[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1462-Course-Schedule-IV"><a href="#1462-Course-Schedule-IV" class="headerlink" title="1462. Course Schedule IV"></a>1462. Course Schedule IV</h3><p>和上题差不多，问题不一样，问的是根据给定的依赖关系，判断两节课是否有依赖。<br><a href="https://leetcode.com/problems/course-schedule-iv/" target="_blank" rel="noopener">查看原题</a></p>
<ul>
<li><p>bfs. 拓扑排序。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    degree = [<span class="number">0</span>] * n</span><br><span class="line">    pres = [set() <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> prerequisites:</span><br><span class="line">        g[u].append(v)</span><br><span class="line">        degree[v] -= <span class="number">1</span></span><br><span class="line">        pres[v].add(u)</span><br><span class="line">    bfs = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">if</span> degree[i]==<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bfs:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g[i]:</span><br><span class="line">            degree[j] += <span class="number">1</span></span><br><span class="line">            pres[j] |= pres[i]</span><br><span class="line">            <span class="keyword">if</span> degree[j] == <span class="number">0</span>:</span><br><span class="line">                bfs.append(j)</span><br><span class="line">    <span class="keyword">return</span> [a <span class="keyword">in</span> pres[b] <span class="keyword">for</span> a, b <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><a href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero" class="headerlink" title="1466. Reorder Routes to Make All Paths Lead to the City Zero"></a>1466. Reorder Routes to Make All Paths Lead to the City Zero</h3><p>有一个有向图，两个节点之间只有一条边，要求所有的边指向0，需要改多少条边的方向。<br><a href="https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6, connections &#x3D; [[0,1],[1,3],[2,3],[4,0],[4,5]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minReorder</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    g1 = collections.defaultdict(list)</span><br><span class="line">    g2 = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> connections:</span><br><span class="line">        g1[u].append(v)</span><br><span class="line">        g2[v].append(u)</span><br><span class="line">    </span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">        seen.add(i)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g1[i]:</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                ans += <span class="number">1</span> + dfs(j)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> g2[i]:</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                ans += dfs(k)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="1210-Minimum-Moves-to-Reach-Target-with-Rotations"><a href="#1210-Minimum-Moves-to-Reach-Target-with-Rotations" class="headerlink" title="1210. Minimum Moves to Reach Target with Rotations"></a>1210. Minimum Moves to Reach Target with Rotations</h3><p>一个占位2格的蛇，从左上走到右下需要最少的步数，可以旋转。<br><a href="https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[0,0,0,0,0,1],</span><br><span class="line">               [1,1,0,0,1,0],</span><br><span class="line">               [0,0,0,0,1,1],</span><br><span class="line">               [0,0,1,0,1,0],</span><br><span class="line">               [0,1,1,0,0,0],</span><br><span class="line">               [0,1,1,0,0,0]]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation:</span><br><span class="line">One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将蛇的横竖状态记录，这样一个点也能表示。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumMoves</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(g)</span><br><span class="line">    q, seen, target = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)], set(), (n<span class="number">-1</span>, n<span class="number">-2</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> r, c, dr, step <span class="keyword">in</span> q:</span><br><span class="line">        <span class="keyword">if</span> (r, c, dr) == target: <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">if</span> (r, c, dr) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add((r, c, dr))</span><br><span class="line">            <span class="keyword">if</span> dr:</span><br><span class="line">                <span class="keyword">if</span> c+<span class="number">1</span>&lt;n <span class="keyword">and</span> g[r][c+<span class="number">1</span>]==g[r+<span class="number">1</span>][c+<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r, c+<span class="number">1</span>, <span class="number">1</span>, step+<span class="number">1</span>), (r, c, <span class="number">0</span>, step+<span class="number">1</span>)]</span><br><span class="line">                <span class="keyword">if</span> r+<span class="number">2</span>&lt;n <span class="keyword">and</span> g[r+<span class="number">2</span>][c]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r+<span class="number">1</span>, c, <span class="number">1</span>, step+<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> r+<span class="number">1</span>&lt;n <span class="keyword">and</span> g[r+<span class="number">1</span>][c]==g[r+<span class="number">1</span>][c+<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r+<span class="number">1</span>, c, <span class="number">0</span>, step+<span class="number">1</span>), (r, c, <span class="number">1</span>, step+<span class="number">1</span>)]</span><br><span class="line">                <span class="keyword">if</span> c+<span class="number">2</span>&lt;n <span class="keyword">and</span> g[r][c+<span class="number">2</span>]==<span class="number">0</span>:</span><br><span class="line">                    q += [(r, c+<span class="number">1</span>, <span class="number">0</span>, step+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="1202-Smallest-String-With-Swaps"><a href="#1202-Smallest-String-With-Swaps" class="headerlink" title="1202. Smallest String With Swaps"></a>1202. Smallest String With Swaps</h3><p>给定一组pairs表明索引对可以互换，求这个字符串能换的最小值时多少，同一对可以进行多次互换。<br><a href="https://leetcode.com/problems/smallest-string-with-swaps/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;dcab&quot;, pairs &#x3D; [[0,3],[1,2]]</span><br><span class="line">Output: &quot;bacd&quot;</span><br><span class="line">Explaination: </span><br><span class="line">Swap s[0] and s[3], s &#x3D; &quot;bcad&quot;</span><br><span class="line">Swap s[1] and s[2], s &#x3D; &quot;bacd&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>union-find</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestStringWithSwaps</span><span class="params">(self, s: str, pairs: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UF</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">            self.p = list(range(n))</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">            self.p[self.find(x)] = self.find(y)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x!=self.p[x]:</span><br><span class="line">                self.p[x] = self.find(self.p[x])</span><br><span class="line">            <span class="keyword">return</span> self.p[x]</span><br><span class="line">    uf, res, m = UF(len(s)), [], defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> pairs:</span><br><span class="line">        uf.union(x, y)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        m[uf.find(i)].append(s[i])</span><br><span class="line">    <span class="keyword">for</span> comp_id <span class="keyword">in</span> m.keys(): </span><br><span class="line">        m[comp_id].sort(reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): </span><br><span class="line">        res.append(m[uf.find(i)].pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="787-Cheapest-Flights-Within-K-Stops"><a href="#787-Cheapest-Flights-Within-K-Stops" class="headerlink" title="787. Cheapest Flights Within K Stops"></a>787. Cheapest Flights Within K Stops</h3><p>经过K个站点的最便宜的航班。<br><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/" target="_blank" rel="noopener">查看原题</a></p>
<ul>
<li><p>狄克斯特拉算法，只不过多了一个条件，经过K个站点。不需要用seen记录已经去过的点，因为该点可能有更少步数的到达方式。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n: int, flights: List[List[int]], src: int, dst: int, K: int)</span> -&gt; int:</span></span><br><span class="line">    g = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> flights:</span><br><span class="line">        g[u].append((v, w))</span><br><span class="line">    </span><br><span class="line">    q = [(<span class="number">0</span>, src, <span class="number">0</span>)]</span><br><span class="line">    heapq.heapify(q)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        p, city, step = heapq.heappop(q)</span><br><span class="line">        <span class="keyword">if</span> city == dst:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">for</span> v, w <span class="keyword">in</span> g[city]:</span><br><span class="line">            <span class="keyword">if</span> step &lt; K+<span class="number">1</span>:</span><br><span class="line">                heapq.heappush(q, (p+w, v, step+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/10/18/math/" rel="prev" title="Math(数学)">
      <i class="fa fa-chevron-left"></i> Math(数学)
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/10/23/stack/" rel="next" title="Stack(堆栈)">
      Stack(堆栈) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于图"><span class="nav-number">1.</span> <span class="nav-text">关于图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode真题"><span class="nav-number">2.</span> <span class="nav-text">LeetCode真题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#990-Satisfiability-of-Equality-Equations"><span class="nav-number">2.1.</span> <span class="nav-text">990. Satisfiability of Equality Equations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#997-Find-the-Town-Judge"><span class="nav-number">2.2.</span> <span class="nav-text">997. Find the Town Judge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#133-Clone-Graph"><span class="nav-number">2.3.</span> <span class="nav-text">133. Clone Graph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance"><span class="nav-number">2.4.</span> <span class="nav-text">1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1267-Count-Servers-that-Communicate"><span class="nav-number">2.5.</span> <span class="nav-text">1267. Count Servers that Communicate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#886-Possible-Bipartition"><span class="nav-number">2.6.</span> <span class="nav-text">886. Possible Bipartition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#207-Course-Schedule"><span class="nav-number">2.7.</span> <span class="nav-text">207. Course Schedule</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1462-Course-Schedule-IV"><span class="nav-number">2.8.</span> <span class="nav-text">1462. Course Schedule IV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><span class="nav-number">2.9.</span> <span class="nav-text">1466. Reorder Routes to Make All Paths Lead to the City Zero</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1210-Minimum-Moves-to-Reach-Target-with-Rotations"><span class="nav-number">2.10.</span> <span class="nav-text">1210. Minimum Moves to Reach Target with Rotations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1202-Smallest-String-With-Swaps"><span class="nav-number">2.11.</span> <span class="nav-text">1202. Smallest String With Swaps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#787-Cheapest-Flights-Within-K-Stops"><span class="nav-number">2.12.</span> <span class="nav-text">787. Cheapest Flights Within K Stops</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wade</p>
  <div class="site-description" itemprop="description">用时间换空间，用空间换时间</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wade</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
