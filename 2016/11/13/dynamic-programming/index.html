<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wadeee.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="你一定听过基于连通性状态压缩的动态规划问题  关于动态规划动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生">
<meta property="og:type" content="article">
<meta property="og:title" content="Dynamic Programming(动态规划)">
<meta property="og:url" content="https://wadeee.github.io/2016/11/13/dynamic-programming/index.html">
<meta property="og:site_name" content="Wade">
<meta property="og:description" content="你一定听过基于连通性状态压缩的动态规划问题  关于动态规划动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2016-11-12T16:00:00.000Z">
<meta property="article:modified_time" content="2020-08-01T11:00:40.531Z">
<meta property="article:author" content="Wade">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wadeee.github.io/2016/11/13/dynamic-programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Dynamic Programming(动态规划) | Wade</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wade</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Know yourself.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://wadeee.github.io/2016/11/13/dynamic-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wade">
      <meta itemprop="description" content="用时间换空间，用空间换时间">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wade">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dynamic Programming(动态规划)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-11-13 00:00:00" itemprop="dateCreated datePublished" datetime="2016-11-13T00:00:00+08:00">2016-11-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>你一定听过基于连通性状态压缩的动态规划问题</p>
</blockquote>
<h2 id="关于动态规划"><a href="#关于动态规划" class="headerlink" title="关于动态规划"></a>关于动态规划</h2><p>动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果 [1]  。</p>
<h2 id="LeetCode真题"><a href="#LeetCode真题" class="headerlink" title="LeetCode真题"></a>LeetCode真题</h2><h3 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h3><p>爬楼梯，一次可以爬一阶或两阶楼梯，爬上n阶楼梯有多少种方法？<br><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">查看原题</a></p>
<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    a = b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="746-Min-Cost-Climbing-Stairs"><a href="#746-Min-Cost-Climbing-Stairs" class="headerlink" title="746. Min Cost Climbing Stairs"></a>746. Min Cost Climbing Stairs</h3><p>楼梯上每层写了到达该层的卡路里，求上到顶层消耗的最小卡路里。<br><a href="https://leetcode.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: cost &#x3D; [10, 15, 20]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</span><br><span class="line"></span><br><span class="line">Input: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</span><br></pre></td></tr></table></figure>

<ul>
<li><p>到达一层有两种选择，一种是上一层，一种是上两层。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">    f1 = f2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> reversed(cost):</span><br><span class="line">        f1, f2 = min(f1, f2) + x, f1</span><br><span class="line">    <span class="keyword">return</span> min(f1, f2)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h3><p>买入卖出最大收益。原题<br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.</span><br><span class="line">             Not 7-1 &#x3D; 6, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其实就是求最高峰点和前面最低谷点的差。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    ans, min_buy = <span class="number">0</span>, float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">        <span class="keyword">if</span> price &lt; min_buy:</span><br><span class="line">            min_buy = price</span><br><span class="line">        <span class="keyword">elif</span> price-min_buy &gt; ans:</span><br><span class="line">            ans = price - min_buy</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><p>买入卖出，允许多次交易。<br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">             Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>比较每两天的价格，如果是涨价了，那就把收益计算进去，否则不出手交易。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_profit</span><span class="params">(prices)</span>:</span></span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">            profit += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：弗洛伊德算法，这个时间复杂度为O(N^3)，space: O(N^2)但是代码简单。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], maxd: int)</span> -&gt; int:</span></span><br><span class="line">    dis = [[float(<span class="string">'inf'</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i, j, w <span class="keyword">in</span> edges:</span><br><span class="line">        dis[i][j] = dis[j][i] = w</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dis[i][i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j])</span><br><span class="line">    ans = &#123;sum(d&lt;=maxd <span class="keyword">for</span> d <span class="keyword">in</span> dis[i]): i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;  <span class="comment"># 这里id大的会将小的覆盖</span></span><br><span class="line">    <span class="keyword">return</span> ans[min(ans)]</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h3><p>最多允许交易两次。<br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">查看原题</a></p>
<ul>
<li><p>先从左到右按照一次交易计算每天的利润。然后按照从右到左，判断如果进行第二次交易，最大的利润。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    min_buy = float(<span class="string">'inf'</span>)</span><br><span class="line">    profits = []</span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        min_buy = min(min_buy, p)</span><br><span class="line">        max_profit = max(max_profit, p-min_buy)</span><br><span class="line">        profits.append(max_profit)</span><br><span class="line">    </span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line">    total_profit = <span class="number">0</span></span><br><span class="line">    max_sell = float(<span class="string">'-inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        max_sell = max(max_sell, prices[i])</span><br><span class="line">        max_profit = max(max_profit, max_sell-prices[i])</span><br><span class="line">        total_profit = max(total_profit, max_profit+profits[i])</span><br><span class="line">    <span class="keyword">return</span> total_profit</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h3><p>抢劫房子问题。不能连续抢劫两个挨着的房间。<br><a href="https://leetcode.com/problems/house-robber" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).</span><br><span class="line">             Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    last, now = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        last, now = now, max(last+num, now)</span><br><span class="line">    <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a>213. House Robber II</h3><p>与上题不同的是，所有的房子连成一个环。<br><a href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2),</span><br><span class="line">             because they are adjacent houses.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意nums长度为1的情况。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robber</span><span class="params">(nums)</span>:</span></span><br><span class="line">        last = now = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            last, now = now, max(last+num, now)</span><br><span class="line">        <span class="keyword">return</span> now</span><br><span class="line">    <span class="keyword">return</span> max(robber(nums[:<span class="number">-1</span>]), robber(nums[len(nums)!=<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="303-Range-Sum-Query-Immutable"><a href="#303-Range-Sum-Query-Immutable" class="headerlink" title="303. Range Sum Query - Immutable"></a>303. Range Sum Query - Immutable</h3><p>给定一个数组，计算索引i, j之间的和。<br><a href="https://leetcode.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>思路：如果单纯采用切片计算，效率过低，题中要求sumRange调用多次。所以这里采用动态规划。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># self.sum_item = [0]</span></span><br><span class="line">        <span class="comment"># for num in nums:</span></span><br><span class="line">        <span class="comment">#     self.sum_item.append(self.sum_item[-1] + num)</span></span><br><span class="line">        <span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</span><br><span class="line">        <span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line">        self.sum_item = list(accumulate(nums, add))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="comment"># return self.sum_item[j+1] - self.sum_item[i] </span></span><br><span class="line">        <span class="keyword">return</span> self.sum_item[j] - self.sum_item[i<span class="number">-1</span>] <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> self.sum_item[j]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h3><p>将数字翻译成字母有多少种方式。<br><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># w tells the number of ways</span></span><br><span class="line">    <span class="comment"># v tells the previous number of ways</span></span><br><span class="line">    <span class="comment"># d is the current digit</span></span><br><span class="line">    <span class="comment"># p is the previous digit</span></span><br><span class="line">    v, w, p = <span class="number">0</span>, int(s&gt;<span class="string">''</span>), <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> s:</span><br><span class="line">        v, w, p = w, int(d&gt;<span class="string">'0'</span>)*w + (<span class="number">9</span>&lt;int(p+d)&lt;<span class="number">27</span>)*v, d</span><br><span class="line">    <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h3><p>一个矩阵中，从左上走到右下有多少种不同走法，每次只能向右或向下移动。<br><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">查看原题</a></p>
<ul>
<li><p>方法一：构建二维矩阵。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    g = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> j==<span class="number">0</span>:</span><br><span class="line">                g[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                g[i][j] = g[i<span class="number">-1</span>][j] + g[i][j<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> g[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：二维数组时没有必要的，仔细观察发现每层都是累计的关系，accumulate为此而生。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    row = [<span class="number">1</span>] * m</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        row = itertools.accumulate(row)</span><br><span class="line">    <span class="keyword">return</span> list(row)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a>63. Unique Paths II</h3><p>和62一样，不同的是中间加了障碍1。<br><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, g: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    R, C = len(g), len(g[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> g[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, C):</span><br><span class="line">        g[<span class="number">0</span>][i] = int(g[<span class="number">0</span>][i<span class="number">-1</span>]==<span class="number">1</span> <span class="keyword">and</span> g[<span class="number">0</span>][i]==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, R):</span><br><span class="line">        g[j][<span class="number">0</span>] = int(g[j<span class="number">-1</span>][<span class="number">0</span>]==<span class="number">1</span> <span class="keyword">and</span> g[j][<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, R):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, C):</span><br><span class="line">            <span class="keyword">if</span> g[i][j] == <span class="number">0</span>:</span><br><span class="line">                g[i][j] = g[i<span class="number">-1</span>][j] + g[i][j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                g[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> g[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h3><p>三角形从上到下最小路径。<br><a href="https://leetcode.com/problems/triangle/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br><span class="line">i.e., 2 + 3 + 5 + 1 &#x3D; 11</span><br></pre></td></tr></table></figure>

<ul>
<li><p>错位相加大法。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine_rows</span><span class="params">(lower_row, upper_row)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [upper + min(lower_left, lower_right)</span><br><span class="line">                <span class="keyword">for</span> upper, lower_left, lower_right <span class="keyword">in</span> </span><br><span class="line">                zip(upper_row, lower_row, lower_row[<span class="number">1</span>:])]</span><br><span class="line">    <span class="keyword">return</span> reduce(combine_rows, triangle[::<span class="number">-1</span>])[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="931-Minimum-Falling-Path-Sum"><a href="#931-Minimum-Falling-Path-Sum" class="headerlink" title="931. Minimum Falling Path Sum"></a>931. Minimum Falling Path Sum</h3><p>和120相似，不过形状变成了矩形。<br><a href="https://leetcode.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: </span><br><span class="line">The possible falling paths are:</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：常规写法。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, A: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    R, C = len(A), len(A[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(R<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(C):</span><br><span class="line">            path = slice(max(<span class="number">0</span>, j<span class="number">-1</span>), min(C, j+<span class="number">2</span>))</span><br><span class="line">            A[i][j] += min(A[i+<span class="number">1</span>][path])</span><br><span class="line">    <span class="keyword">return</span> min(A[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：错位计算的方式，这个比120三角形的要复杂一点。需要填充无穷大来使生效。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, A: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">    padding = [float(<span class="string">'inf'</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine_rows</span><span class="params">(lower_row, upper_row)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [upper + min(lower_left, lower_mid, lower_right)</span><br><span class="line">                <span class="keyword">for</span> upper, lower_left, lower_mid, lower_right <span class="keyword">in</span></span><br><span class="line">                zip(upper_row, lower_row[<span class="number">1</span>:]+padding, lower_row, padding+lower_row[:<span class="number">-1</span>])]</span><br><span class="line">    <span class="keyword">return</span> min(reduce(combine_rows, A[::<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1289-Minimum-Falling-Path-Sum-II"><a href="#1289-Minimum-Falling-Path-Sum-II" class="headerlink" title="1289. Minimum Falling Path Sum II"></a>1289. Minimum Falling Path Sum II</h3><p>上题变形，每行找到非自己那列的元素。<br><a href="https://leetcode.com/problems/minimum-falling-path-sum-ii/" target="_blank" rel="noopener">查看原题</a></p>
<ul>
<li><p>用堆记录2个最小的值。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, arr: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    m, n = len(arr), len(arr[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        r = heapq.nsmallest(<span class="number">2</span>, arr[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            arr[i][j] += r[<span class="number">1</span>] <span class="keyword">if</span> arr[i<span class="number">-1</span>][j]==r[<span class="number">0</span>] <span class="keyword">else</span> r[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> min(arr[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h3><p>完美平方，找出n的最少的能被几个平方数相加。<br><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>f(n)表示n最少的个数。f(n)=min(f(n-1²), f(n-2²)…f(0)) + 1</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    _dp = [<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = self._dp</span><br><span class="line">        <span class="keyword">while</span> len(dp) &lt;= n:</span><br><span class="line">            <span class="comment"># dp.append(min(dp[len(dp)-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1)</span></span><br><span class="line">            dp.append(min(dp[-i*i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(len(dp)**<span class="number">0.5</span>+<span class="number">1</span>))) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h3><p>最长回文子字符串。<br><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>马拉车算法。Time: O(n).</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">    <span class="comment"># Transform S into T.</span></span><br><span class="line">    <span class="comment"># For example, S = "abba", T = "^#a#b#b#a#$".</span></span><br><span class="line">    <span class="comment"># ^ and $ signs are sentinels appended to each end to avoid bounds checking</span></span><br><span class="line">    T = <span class="string">'#'</span>.join(<span class="string">'^&#123;&#125;$'</span>.format(s))</span><br><span class="line">    n = len(T)</span><br><span class="line">    P = [<span class="number">0</span>] * n</span><br><span class="line">    C = R = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">1</span>, n<span class="number">-1</span>):</span><br><span class="line">        P[i] = (R &gt; i) <span class="keyword">and</span> min(R - i, P[<span class="number">2</span>*C - i]) <span class="comment"># equals to i' = C - (i-C)</span></span><br><span class="line">        <span class="comment"># Attempt to expand palindrome centered at i</span></span><br><span class="line">        <span class="keyword">while</span> T[i + <span class="number">1</span> + P[i]] == T[i - <span class="number">1</span> - P[i]]:</span><br><span class="line">            P[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If palindrome centered at i expand past R,</span></span><br><span class="line">        <span class="comment"># adjust center based on expanded palindrome.</span></span><br><span class="line">        <span class="keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">            C, R = i, i + P[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the maximum element in P.</span></span><br><span class="line">    maxLen, centerIndex = max((n, i) <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(P))</span><br><span class="line">    <span class="keyword">return</span> s[(centerIndex  - maxLen)//<span class="number">2</span>: (centerIndex  + maxLen)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1024-Video-Stitching"><a href="#1024-Video-Stitching" class="headerlink" title="1024. Video Stitching"></a>1024. Video Stitching</h3><p>影片剪辑，给定n组影片段，求能够拼出0~T完整影片所使用的最小段数。<br><a href="https://leetcode.com/problems/video-stitching/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: clips &#x3D; [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T &#x3D; 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.</span><br><span class="line">Then, we can reconstruct the sporting event as follows:</span><br><span class="line">We cut [1,9] into segments [1,2] + [2,8] + [8,9].</span><br><span class="line">Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">videoStitching</span><span class="params">(self, clips: List[List[int]], T: int)</span> -&gt; int:</span></span><br><span class="line">    end, end2, cnt = <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>   <span class="comment"># end 表示上一段最后截止点，end2表示当前可以最大延伸的最远地点。</span></span><br><span class="line">    <span class="keyword">for</span> s, e <span class="keyword">in</span> sorted(clips):</span><br><span class="line">        <span class="keyword">if</span> end2 &gt;= T <span class="keyword">or</span> s &gt; end2:   <span class="comment"># 完成或者接不上了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> end &lt; s &lt;= end2:       <span class="comment"># 续1s</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            end = end2</span><br><span class="line">        end2 = max(end2, e)</span><br><span class="line">    <span class="keyword">return</span> cnt <span class="keyword">if</span> end2 &gt;= T <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1048-Longest-String-Chain"><a href="#1048-Longest-String-Chain" class="headerlink" title="1048. Longest String Chain"></a>1048. Longest String Chain</h3><p>每个字符添加任意一个字符，可以组成一个字符串链。<br><a href="https://leetcode.com/problems/longest-string-chain/" target="_blank" rel="noopener">查看原题</a></p>
<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">    words2 = &#123;i:set() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">17</span>)&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        words2[len(word)].add(word)</span><br><span class="line">    dp = collections.defaultdict(<span class="keyword">lambda</span> : <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">17</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words2[k]:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                prev = w[:i] + w[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> prev <span class="keyword">in</span> words2[k<span class="number">-1</span>]:</span><br><span class="line">                    <span class="comment"># dp[w] = max(dp[w], dp[prev]+1)</span></span><br><span class="line">                    dp[w] = dp[prev] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max(dp.values() <span class="keyword">or</span> [<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1143-Longest-Common-Subsequence"><a href="#1143-Longest-Common-Subsequence" class="headerlink" title="1143. Longest Common Subsequence"></a>1143. Longest Common Subsequence</h3><p>最长公共子串的长度。<br><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">Output: 3  </span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：递归</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> j&lt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> text1[i]==text2[j]:</span><br><span class="line">                <span class="keyword">return</span> helper(i<span class="number">-1</span>,j<span class="number">-1</span>)+<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> max(helper(i<span class="number">-1</span>,j),helper(i,j<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> helper(len(text1)<span class="number">-1</span>,len(text2)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：迭代。dp(i,j) means the longest common subsequence of text1[:i] and text2[:j].</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">    n1, n2 = len(text1), len(text2)</span><br><span class="line">    dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n1+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n2):</span><br><span class="line">            <span class="keyword">if</span> text1[i] == text2[j]:</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1312-Minimum-Insertion-Steps-to-Make-a-String-Palindrome"><a href="#1312-Minimum-Insertion-Steps-to-Make-a-String-Palindrome" class="headerlink" title="1312. Minimum Insertion Steps to Make a String Palindrome"></a>1312. Minimum Insertion Steps to Make a String Palindrome</h3><p>将一个字符串变为回文串，最小插入字母步数。<br><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;zzazz&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The string &quot;zzazz&quot; is already palindrome we don&#39;t need any insertions.</span><br><span class="line">Input: s &#x3D; &quot;leetcode&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Inserting 5 characters the string becomes &quot;leetcodocteel&quot;.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>和1134，Longest Common Subsequence一样，当这个字符串和他倒序的公共子串越多，需要添加的字母就越少。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minInsertions</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span> <span class="keyword">if</span> s[i] == s[~j] <span class="keyword">else</span> max(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> n - dp[n][n]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="221-Maximal-Square"><a href="#221-Maximal-Square" class="headerlink" title="221. Maximal Square"></a>221. Maximal Square</h3><p>最大的正方形岛屿面积。<br><a href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：此题看似和最大岛屿面积相似，但解法完全不同。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">    max_side = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = min(dp[i][j], dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                max_side = max(max_side, dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> max_side**<span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1340-Jump-Game-V"><a href="#1340-Jump-Game-V" class="headerlink" title="1340. Jump Game V"></a>1340. Jump Game V</h3><p>跳跃游戏，可以向左右d范围内矮的地方跳下。<br><a href="https://leetcode.com/problems/jump-game-v/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [6,4,14,6,8,13,9,7,10,6,12], d &#x3D; 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: You can start at index 10. You can jump 10 --&gt; 8 --&gt; 6 --&gt; 7 as shown.</span><br><span class="line">Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 &gt; 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 &gt; 9.</span><br><span class="line">Similarly You cannot jump from index 3 to index 2 or index 1.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxJumps</span><span class="params">(self, arr: List[int], d: int)</span> -&gt; int:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> ans[i]: <span class="keyword">return</span> ans[i]</span><br><span class="line">        ans[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> di <span class="keyword">in</span> (<span class="number">-1</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+di, i+d*di+di, di):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> arr[j]&lt;arr[i]): <span class="keyword">break</span></span><br><span class="line">                ans[i] = max(ans[i], jump(j)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans[i]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1301-Number-of-Paths-with-Max-Score"><a href="#1301-Number-of-Paths-with-Max-Score" class="headerlink" title="1301. Number of Paths with Max Score"></a>1301. Number of Paths with Max Score</h3><p>左上到右下，最大值，路径中存在障碍，并且需要返回路径的个数。<br><a href="https://leetcode.com/problems/number-of-paths-with-max-score/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [&quot;E23&quot;,&quot;2X2&quot;,&quot;12S&quot;]</span><br><span class="line">Output: [7,1]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathsWithMaxScore</span><span class="params">(self, board: List[str])</span> -&gt; List[int]:</span></span><br><span class="line">    n, mod = len(board), <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">    dp = [[[float(<span class="string">'-inf'</span>), <span class="number">0</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[n<span class="number">-1</span>][n<span class="number">-1</span>] = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(n)[::<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(n)[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> board[x][y] <span class="keyword">in</span> <span class="string">'XS'</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> dp[x][y][<span class="number">0</span>] &lt; dp[x+i][y+j][<span class="number">0</span>]:</span><br><span class="line">                    dp[x][y] = [dp[x+i][y+j][<span class="number">0</span>], <span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> dp[x][y][<span class="number">0</span>] == dp[x+i][y+j][<span class="number">0</span>]:</span><br><span class="line">                    dp[x][y][<span class="number">1</span>] += dp[x+i][y+j][<span class="number">1</span>]</span><br><span class="line">            dp[x][y][<span class="number">0</span>] += int(board[x][y]) <span class="keyword">if</span> x <span class="keyword">or</span> y <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> [dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">if</span> dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] % mod]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1277-Count-Square-Submatrices-with-All-Ones"><a href="#1277-Count-Square-Submatrices-with-All-Ones" class="headerlink" title="1277. Count Square Submatrices with All Ones"></a>1277. Count Square Submatrices with All Ones</h3><p>矩阵中最多有多少个1构成的正方形。<br><a href="https://leetcode.com/problems/count-square-submatrices-with-all-ones/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [0,1,1,1],</span><br><span class="line">  [1,1,1,1],</span><br><span class="line">  [0,1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: </span><br><span class="line">There are 10 squares of side 1.</span><br><span class="line">There are 4 squares of side 2.</span><br><span class="line">There is  1 square of side 3.</span><br><span class="line">Total number of squares &#x3D; 10 + 4 + 1 &#x3D; 15.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSquares</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    m, n = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># dp[i][j] 表示以i, j为右下点时，正方形的个数。</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (n) <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> mat[i][j] == <span class="number">1</span>:</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum(map(sum, dp))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1269-Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps"><a href="#1269-Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps" class="headerlink" title="1269. Number of Ways to Stay in the Same Place After Some Steps"></a>1269. Number of Ways to Stay in the Same Place After Some Steps</h3><p>回到原点的走法一共有多少种，一次只能向右，向左或者停留，要求始终保持在数组范围。<br><a href="https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: steps &#x3D; 3, arrLen &#x3D; 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 differents ways to stay at index 0 after 3 steps.</span><br><span class="line">Right, Left, Stay</span><br><span class="line">Stay, Right, Left</span><br><span class="line">Right, Stay, Left</span><br><span class="line">Stay, Stay, Stay</span><br></pre></td></tr></table></figure>

<ul>
<li><p>找到状态转移方程，<code>dp[p][s] = dp[p-1][s-1] + dp[p][s-1] + dp[p+1, s-1]</code>p代表位置，s代表步数。首部添加0方便求和。注意t+3这个范围。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSquares</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    m, n = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># dp[i][j] 表示以i, j为右下点时，正方形的个数。</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (n) <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> mat[i][j] == <span class="number">1</span>:</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum(map(sum, dp))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h3><p>返回从0到num的数中，每个数二进制中含有1的个数。<br><a href="https://leetcode.com/problems/counting-bits/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>dp 。<code>f[i]=f[i//2]+i&amp;1</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSquares</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    m, n = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># dp[i][j] 表示以i, j为右下点时，正方形的个数。</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (n) <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> mat[i][j] == <span class="number">1</span>:</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum(map(sum, dp))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1262-Greatest-Sum-Divisible-by-Three"><a href="#1262-Greatest-Sum-Divisible-by-Three" class="headerlink" title="1262. Greatest Sum Divisible by Three"></a>1262. Greatest Sum Divisible by Three</h3><p>最多的元素和能被3整除。<br><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,6,5,1,8]</span><br><span class="line">Output: 18</span><br><span class="line">Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># dp[pos][mod]</span></span><br><span class="line">    <span class="comment"># # 0  1  2</span></span><br><span class="line">    <span class="comment"># 0 3  0  0</span></span><br><span class="line">    <span class="comment"># 1 9  0  0 </span></span><br><span class="line">    <span class="comment"># 2 9  0  14</span></span><br><span class="line">    <span class="comment"># 3 15 10 14</span></span><br><span class="line">    <span class="comment"># 4 18 22 23</span></span><br><span class="line">    dp = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> dp[:]:</span><br><span class="line">            dp[(j+a) % <span class="number">3</span>] = max(dp[(j+a) % <span class="number">3</span>], j+a)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h3><p>两个单词，将a变成b的最小步数，可以添加、删除，替换一个字母。<br><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (remove &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (remove &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">    m, n = len(word1), len(word2)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = j</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> word1[i] == word2[j]:</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = min(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>], dp[i][j]) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a>518. Coin Change 2</h3><p>找钱问题，给你几种面值的硬币，不限制每种硬币的个数，问组成多少钱有多少种方法。<br><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;2+2+1</span><br><span class="line">5&#x3D;2+1+1+1</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>背包问题</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> coins:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">           <span class="keyword">if</span> j &gt;= i:</span><br><span class="line">               dp[j] += dp[j - i]</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1220-Count-Vowels-Permutation"><a href="#1220-Count-Vowels-Permutation" class="headerlink" title="1220. Count Vowels Permutation"></a>1220. Count Vowels Permutation</h3><p>元音字母的全排列，根据指定规则的，求全排列的个数。<br><a href="https://leetcode.com/problems/count-vowels-permutation/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: All possible strings are: &quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; and &quot;ua&quot;.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>背包问题</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countVowelPermutation</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    a = e = i = o = u = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        a, e, i, o, u = e, a+i, a+e+o+u, i+u, a</span><br><span class="line">    <span class="keyword">return</span> (a+e+i+o+u) % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="368-Largest-Divisible-Subset"><a href="#368-Largest-Divisible-Subset" class="headerlink" title="368. Largest Divisible Subset"></a>368. Largest Divisible Subset</h3><p>最大的整除子集。<br><a href="https://leetcode.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2] (of course, [1,3] will also be ok)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>背包问题</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestDivisibleSubset</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    S = &#123;<span class="number">-1</span>: set()&#125;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> sorted(nums):</span><br><span class="line">        S[x] = max((S[d] <span class="keyword">for</span> d <span class="keyword">in</span> S <span class="keyword">if</span> x % d == <span class="number">0</span>), key=len) | &#123;x&#125;</span><br><span class="line">    <span class="keyword">return</span> list(max(S.values(), key=len))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5456-Kth-Ancestor-of-a-Tree-Node"><a href="#5456-Kth-Ancestor-of-a-Tree-Node" class="headerlink" title="5456. Kth Ancestor of a Tree Node"></a>5456. Kth Ancestor of a Tree Node</h3><p>找出一个树节点的k个祖先。<br><a href="https://leetcode.com/problems/kth-ancestor-of-a-tree-node/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;TreeAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;]</span><br><span class="line">[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[null,1,0,-1]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">TreeAncestor treeAncestor &#x3D; new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);</span><br><span class="line"></span><br><span class="line">treeAncestor.getKthAncestor(3, 1);  &#x2F;&#x2F; returns 1 which is the parent of 3</span><br><span class="line">treeAncestor.getKthAncestor(5, 2);  &#x2F;&#x2F; returns 0 which is the grandparent of 5</span><br><span class="line">treeAncestor.getKthAncestor(6, 3);  &#x2F;&#x2F; returns -1 because there is no such ancestor</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用的倍增法，binary lifting.</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeAncestor</span>:</span></span><br><span class="line"></span><br><span class="line">    step = <span class="number">15</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, A)</span>:</span></span><br><span class="line">        A = dict(enumerate(A))</span><br><span class="line">        jump = [A]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> range(self.step):</span><br><span class="line">            B = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> A[i] <span class="keyword">in</span> A:</span><br><span class="line">                    B[i] = A[A[i]]</span><br><span class="line">            jump.append(B)</span><br><span class="line">            A = B</span><br><span class="line">        self.jump = jump</span><br><span class="line">        print(jump)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthAncestor</span><span class="params">(self, x: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        step = self.step</span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> x &gt; <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> k &gt;= <span class="number">1</span> &lt;&lt; step:</span><br><span class="line">                x = self.jump[step].get(x, <span class="number">-1</span>)</span><br><span class="line">                k -= <span class="number">1</span> &lt;&lt; step</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                step -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1477-Find-Two-Non-overlapping-Sub-arrays-Each-With-Target-Sum"><a href="#1477-Find-Two-Non-overlapping-Sub-arrays-Each-With-Target-Sum" class="headerlink" title="1477. Find Two Non-overlapping Sub-arrays Each With Target Sum"></a>1477. Find Two Non-overlapping Sub-arrays Each With Target Sum</h3><p>找到数组中等于目标值的两个不重叠子数组的最小长度和。<br><a href="https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [3,2,2,4,3], target &#x3D; 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Only two sub-arrays have sum &#x3D; 3 ([3] and [3]). The sum of their lengths is 2.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法一：看了提示后使用了前后遍历法做出来的。其实有一次遍历的方式。这个方法看了挺长时间，才明白，实际上记录了一个以end为结尾的前面的所有元素最好的长度是多少。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSumOfLengths</span><span class="params">(self, arr: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    prefix = &#123;<span class="number">0</span>: <span class="number">-1</span>&#125;</span><br><span class="line">    best_till = [math.inf] * len(arr)</span><br><span class="line">    ans = best = math.inf</span><br><span class="line">    <span class="keyword">for</span> i, curr <span class="keyword">in</span> enumerate(itertools.accumulate(arr)):</span><br><span class="line">        <span class="comment"># print(i, curr)</span></span><br><span class="line">        <span class="keyword">if</span> curr - target <span class="keyword">in</span> prefix:</span><br><span class="line">            end = prefix[curr - target]</span><br><span class="line">            <span class="keyword">if</span> end &gt; <span class="number">-1</span>:</span><br><span class="line">                ans = min(ans, i - end + best_till[end])</span><br><span class="line">            best = min(best, i - end)</span><br><span class="line">            <span class="comment"># print('\t', best, i-end, best_till, ans)</span></span><br><span class="line">        best_till[i] = best</span><br><span class="line">        prefix[curr] = i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> ans == math.inf <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a>494. Target Sum</h3><p>给你一组数，用+或-连接起来最后等于target，问有多少种填法。<br><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums: List[int], S: int)</span> -&gt; int:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line"></span><br><span class="line">    self.memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @functools.lru_cache(maxsize=2**17)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, total)</span>:</span></span><br><span class="line">        <span class="comment"># print(i, total)</span></span><br><span class="line">        <span class="keyword">if</span> (i, total) <span class="keyword">in</span> self.memo:</span><br><span class="line">            <span class="keyword">return</span> self.memo[(i, total)]</span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">            <span class="keyword">return</span> total==S</span><br><span class="line">        ans = dfs(i+<span class="number">1</span>, total+nums[i]) + dfs(i+<span class="number">1</span>, total-nums[i])</span><br><span class="line">        self.memo[(i, total)] = ans</span><br><span class="line">        <span class="comment"># return dfs(i+1, total+nums[i]) + dfs(i+1, total-nums[i])</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="174-Dungeon-Game"><a href="#174-Dungeon-Game" class="headerlink" title="174. Dungeon Game"></a>174. Dungeon Game</h3><p>地牢游戏，从左上走到右下，每次只能像右或者向下，格子里会扣血和加血，问最少需要多少血，全程保持血量为1以上。<br><a href="https://leetcode.com/problems/dungeon-game/" target="_blank" rel="noopener">查看原题</a></p>
<ul>
<li><p>解法</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    R, C = len(dungeon), len(dungeon[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span>] * C <span class="keyword">for</span> _ <span class="keyword">in</span> range(R)] </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(R<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(C<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == R<span class="number">-1</span> <span class="keyword">and</span> j == C<span class="number">-1</span>:</span><br><span class="line">                dp[i][j] = max(<span class="number">1</span>, <span class="number">1</span> - dungeon[i][j])</span><br><span class="line">            <span class="keyword">elif</span> i == R<span class="number">-1</span>:</span><br><span class="line">                dp[i][j] = max(<span class="number">1</span>, dp[i][j+<span class="number">1</span>] - dungeon[i][j])</span><br><span class="line">            <span class="keyword">elif</span> j == C<span class="number">-1</span>:</span><br><span class="line">                dp[i][j] = max(<span class="number">1</span>, dp[i+<span class="number">1</span>][j] - dungeon[i][j])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = max(<span class="number">1</span>, min(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]) - dungeon[i][j])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h3><p>不重复的二叉搜索树，1~n节点。<br><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">查看原题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n &#x3D; 3, there are a total of 5 unique BST&#39;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>状态转移方程式这样的G(n)表示n个节点能组成的二叉搜索树节点个数。F(i, n)表示有n个节点时，以i为root的个数。<code>G(n) = F(1, n) + F(2, n) + ... + F(n, n)</code>. <code>F(3, 7)=G(2)*G(4)</code>即<code>F(i, n) = G(i-1) * G(n-i)</code>, 所以最后<code>G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    G = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">            G[i] += G[j<span class="number">-1</span>]*G[i-j]</span><br><span class="line">    <span class="keyword">return</span> G[n]</span><br></pre></td></tr></table></figure>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/11/02/graph/" rel="prev" title="Graph(图)">
      <i class="fa fa-chevron-left"></i> Graph(图)
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于动态规划"><span class="nav-number">1.</span> <span class="nav-text">关于动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LeetCode真题"><span class="nav-number">2.</span> <span class="nav-text">LeetCode真题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#70-Climbing-Stairs"><span class="nav-number">2.1.</span> <span class="nav-text">70. Climbing Stairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#746-Min-Cost-Climbing-Stairs"><span class="nav-number">2.2.</span> <span class="nav-text">746. Min Cost Climbing Stairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">2.3.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="nav-number">2.4.</span> <span class="nav-text">122. Best Time to Buy and Sell Stock II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Time-to-Buy-and-Sell-Stock-III"><span class="nav-number">2.5.</span> <span class="nav-text">Best Time to Buy and Sell Stock III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-House-Robber"><span class="nav-number">2.6.</span> <span class="nav-text">198. House Robber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#213-House-Robber-II"><span class="nav-number">2.7.</span> <span class="nav-text">213. House Robber II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#303-Range-Sum-Query-Immutable"><span class="nav-number">2.8.</span> <span class="nav-text">303. Range Sum Query - Immutable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#91-Decode-Ways"><span class="nav-number">2.9.</span> <span class="nav-text">91. Decode Ways</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-Unique-Paths"><span class="nav-number">2.10.</span> <span class="nav-text">62. Unique Paths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-Unique-Paths-II"><span class="nav-number">2.11.</span> <span class="nav-text">63. Unique Paths II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#120-Triangle"><span class="nav-number">2.12.</span> <span class="nav-text">120. Triangle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#931-Minimum-Falling-Path-Sum"><span class="nav-number">2.13.</span> <span class="nav-text">931. Minimum Falling Path Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1289-Minimum-Falling-Path-Sum-II"><span class="nav-number">2.14.</span> <span class="nav-text">1289. Minimum Falling Path Sum II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#279-Perfect-Squares"><span class="nav-number">2.15.</span> <span class="nav-text">279. Perfect Squares</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Longest-Palindromic-Substring"><span class="nav-number">2.16.</span> <span class="nav-text">5. Longest Palindromic Substring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1024-Video-Stitching"><span class="nav-number">2.17.</span> <span class="nav-text">1024. Video Stitching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1048-Longest-String-Chain"><span class="nav-number">2.18.</span> <span class="nav-text">1048. Longest String Chain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1143-Longest-Common-Subsequence"><span class="nav-number">2.19.</span> <span class="nav-text">1143. Longest Common Subsequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1312-Minimum-Insertion-Steps-to-Make-a-String-Palindrome"><span class="nav-number">2.20.</span> <span class="nav-text">1312. Minimum Insertion Steps to Make a String Palindrome</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#221-Maximal-Square"><span class="nav-number">2.21.</span> <span class="nav-text">221. Maximal Square</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1340-Jump-Game-V"><span class="nav-number">2.22.</span> <span class="nav-text">1340. Jump Game V</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1301-Number-of-Paths-with-Max-Score"><span class="nav-number">2.23.</span> <span class="nav-text">1301. Number of Paths with Max Score</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1277-Count-Square-Submatrices-with-All-Ones"><span class="nav-number">2.24.</span> <span class="nav-text">1277. Count Square Submatrices with All Ones</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1269-Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps"><span class="nav-number">2.25.</span> <span class="nav-text">1269. Number of Ways to Stay in the Same Place After Some Steps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#338-Counting-Bits"><span class="nav-number">2.26.</span> <span class="nav-text">338. Counting Bits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1262-Greatest-Sum-Divisible-by-Three"><span class="nav-number">2.27.</span> <span class="nav-text">1262. Greatest Sum Divisible by Three</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-Edit-Distance"><span class="nav-number">2.28.</span> <span class="nav-text">72. Edit Distance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#518-Coin-Change-2"><span class="nav-number">2.29.</span> <span class="nav-text">518. Coin Change 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1220-Count-Vowels-Permutation"><span class="nav-number">2.30.</span> <span class="nav-text">1220. Count Vowels Permutation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#368-Largest-Divisible-Subset"><span class="nav-number">2.31.</span> <span class="nav-text">368. Largest Divisible Subset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5456-Kth-Ancestor-of-a-Tree-Node"><span class="nav-number">2.32.</span> <span class="nav-text">5456. Kth Ancestor of a Tree Node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1477-Find-Two-Non-overlapping-Sub-arrays-Each-With-Target-Sum"><span class="nav-number">2.33.</span> <span class="nav-text">1477. Find Two Non-overlapping Sub-arrays Each With Target Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#494-Target-Sum"><span class="nav-number">2.34.</span> <span class="nav-text">494. Target Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#174-Dungeon-Game"><span class="nav-number">2.35.</span> <span class="nav-text">174. Dungeon Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#96-Unique-Binary-Search-Trees"><span class="nav-number">2.36.</span> <span class="nav-text">96. Unique Binary Search Trees</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wade</p>
  <div class="site-description" itemprop="description">用时间换空间，用空间换时间</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wade</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
